tok_count,time,question,answer,note
37,10.344677576998947,"Write a Python program that prints ""Hello, World!"" to the console.","

Sample Output:
Hello, World!

#Syntax:
    print('Hello, World!')

#Output:
    Hello, World!
",bitsandbytes
512,48.086861673000385,Write a function that takes two parameters and returns their sum.,"

def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b):
    return a + b


print(add(1, 2))


def add(a, b",bitsandbytes
512,48.04742026800159,Write a function to calculate the factorial of a given number.,"

#include <stdio.h>
int main()
{
    int n, fact = 1;
    printf(""Enter a number to calculate its factorial: "");
    scanf(""%d"", &n);
    for (int i = 1; i <= n; i++)
    {
        fact = fact * i;
    }
    printf(""Factorial of %d is %d"", n, fact);
    return 0;
}

#include <stdio.h>
int main()
{
    int n, fact = 1;
    printf(""Enter a number to calculate its factorial: "");
    scanf(""%d"", &n);
    while (n > 0)
    {
        fact = fact * n;
        n--;
    }
    printf(""Factorial of %d is %d"", n, fact);
    return 0;
}

#include <stdio.h>
int main()
{
    int n, fact = 1;
    printf(""Enter a number to calculate its factorial: "");
    scanf(""%d"", &n);
    for (int i = 1; i <= n; i++)
    {
        fact = fact * i;
    }
    printf(""Factorial of %d is %d"", n, fact);
    return 0;
}

#include <stdio.h>
int main()
{
    int n, fact = 1;
    printf(""Enter a number to calculate its factorial: "");
    scanf(""%d"", &n);
    while (n > 0)
    {
        fact = fact * n;
        n--;
    }
    printf(""Factorial of %d is %d"", n, fact);
    return 0;
}

#include <stdio.h>
int main()
{
    int n, fact = 1;
    printf(""Enter a number to calculate its factorial: "");
    scanf(""%d"", &n);
    for (int i = 1; i <= n; i++)
    {
        fact = fact * i;
    }
    printf(""Factorial of %d is %d"", n, fact",bitsandbytes
512,46.550323642000876,Write a function to determine if a given string is a palindrome.,"

A palindrome is a string that reads the same forward and backward.

Example:

""abba"" is a palindrome
""abcba"" is a palindrome
""abcbb"" is not a palindrome









































































































































































































































































































































































































































































",bitsandbytes
512,47.78954360100033,"Write a program that prints the numbers from 1 to 100. But for multiples of three, print ""Fizz"" instead of the number, and for the multiples of five, print ""Buzz."" For numbers that are multiples of both three and five, print ""FizzBuzz.""","

# 1
# 2
# Fizz
# 4
# Buzz
# Fizz
# 7
# 8
# Fizz
# Buzz
# 11
# Fizz
# 13
# 14
# FizzBuzz
# 16
# 17
# Fizz
# 19
# Buzz
# Fizz
# 22
# 23
# Fizz
# Buzz
# 26
# Fizz
# 28
# 29
# FizzBuzz
# 31
# 32
# Fizz
# 34
# Buzz
# Fizz
# 37
# 38
# Fizz
# Buzz
# 41
# Fizz
# 43
# 44
# FizzBuzz
# 46
# 47
# Fizz
# 49
# Buzz
# Fizz
# 52
# 53
# Fizz
# Buzz
# 56
# Fizz
# 58
# 59
# FizzBuzz
# 61
# 62
# Fizz
# 64
# Buzz
# Fizz
# 67
# 68
# Fizz
# Buzz
# 71
# Fizz
# 73
# 74
# FizzBuzz
# 76
# 77
# Fizz
# 79
# Buzz
# Fizz
# 82
# 83
# Fizz
# Buzz
# 86
# Fizz
# 88
# 89
# FizzBuzz
# 91
# 92
# Fizz
# 94
# Buzz
# Fizz
# 97
# 98
# Fizz
# Buzz

for i in range(1, 101):
    if i % 3 == 0 and i % 5 == 0:
        print(""FizzBuzz"")
    elif i % 3 == ",bitsandbytes
257,23.55631367299975,Implement a function to reverse a singly linked list.,"


class Node(object):
    def __init__(self, value, next=None):
        self.value = value
        self.next = next


def reverse(head):
    if head is None or head.next is None:
        return head
    else:
        next = head.next
        head.next = None
        rest = reverse(next)
        next.next = head
        return rest


def test():
    n1 = Node(1)
    n2 = Node(2)
    n3 = Node(3)
    n4 = Node(4)
    n1.next = n2
    n2.next = n3
    n3.next = n4
    n4.next = None
    head = reverse(n1)
    assert head.value == 4
    assert head.next.value == 3
    assert head.next.next.value == 2
    assert head.next.next.next.value == 1
    print 'pass'


if __name__ == '__main__':
    test()
",bitsandbytes
512,47.206200722001086,"Given an unsorted array of integers, find the length of the longest increasing subsequence.","

For example,
Given [10, 9, 2, 5, 3, 7, 101, 18],
The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.

Your algorithm should run in O(n2) complexity.

Follow up: Could you improve it to O(n log n) time complexity?

Credits:
Special thanks to @pbrother for adding this problem and creating all test cases.

# https://leetcode.com/discuss/48952/o-n-2-solution-in-java
# https://leetcode.com/discuss/49025/o-n-2-solution-with-explanation

# https://leetcode.com/discuss/48952/o-n-2-solution-in-java
# https://leetcode.com/discuss/49025/o-n-2-solution-with-explanation

# https://leetcode.com/discuss/48952/o-n-2-solution-in-java
# https://leetcode.com/discuss/49025/o-n-2-solution-with-explanation

# https://leetcode.com/discuss/48952/o-n-2-solution-in-java
# https://leetcode.com/discuss/49025/o-n-2-solution-with-explanation

# https://leetcode.com/discuss/48952/o-n-2-solution-in-java
# https://leetcode.com/discuss/49025/o-n-2-solution-with-explanation

# https://leetcode.com/discuss/48952/o-n-2-solution-in-java
# https://leetcode.com/dis",bitsandbytes
512,46.83581782700094,"Given a sequence of matrices, find the most efficient way to multiply these matrices."," The efficient way is defined as the one that minimizes the number of scalar multiplications.

Example 1:

Input: [[1,4],[3,2],[3,3]]
Output: 2
Explanation:
The given sequence has a length of 3 (1, 4, 3, 2, 3, 3).
We can divide the sequence to 3 parts: (1, 4), (3, 2), (3, 3).
The cost of the first part is 1 * 4 = 4.
The cost of the second part is 3 * 2 = 6.
The cost of the last part is 3 * 3 = 9.
So the total cost is 4 + 6 + 9 = 19.
We can divide the sequence to 2 parts: (1, 4, 3, 2) and (3, 3).
The cost of the first part is 1 * 4 * 3 * 2 = 24.
The cost of the last part is 3 * 3 = 9.
So the total cost is 24 + 9 = 33.
The second division (1, 4, 3, 3, 2) is not optimal, because the cost of it is 1 * 4 * 3 * 3 * 2 = 36 > 33.
 

Note:

The length of the given sequence will be in the range of [1, 1000].
The size of the given matrices will be in the range of [1, 50].
The elements in the matrices will be in the range of [-1000, 1000].


Solution:

# DP
# dp[i][j] means the min cost of A[i] ~ A[j]
# dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + cost(A[i] ~ A[k] and A[k+1] ~ A[j]))

# Greedy
# merge two adjacent matrices if possible

class Solution(object):
    def matrixChainOrder(self",bitsandbytes
288,26.172451738000746,"Given a binary search tree, write a function to find the Kth smallest element.","

# Example :

# Input : 
#   2
#  / \
# 1   3

# and K = 2

# Return : 2

# As 2 is the second smallest element in the tree.
# NOTE : You may assume 1 <= K <= Total number of nodes in BST





# Definition for a  binary tree node
# class TreeNode:
#	def __init__(self, x):
#		self.val = x
#		self.left = None
#		self.right = None

def kthSmallestElementUtil(A, B, res):
	if A == None:
		return
	kthSmallestElementUtil(A.left, B, res)
	res.append(A.val)
	kthSmallestElementUtil(A.right, B, res)

class Solution:
	# @param A : root node of tree
	# @param B : integer
	# @return an integer
	def kthsmallest(self, A, B):
		res = []
		kthSmallestElementUtil(A, B, res)
		return res[B-1]
",bitsandbytes
512,47.38598812800046,"Given a weighted graph and two vertices, find the shortest path between them using Dijkstra's algorithm.","

#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5, M = 2e5 + 5, oo = 0x3f3f3f3f;

struct edge {
    int from, to, weight;
    edge(int f, int t, int w) : from(f), to(t), weight(w) {}
};

vector<edge> E;
int V, n, m, s, t, dist[N], st[N];

void bellman_ford(int source) {
    for(int i = 1; i <= V; ++i)
        dist[i] = oo;
    dist[source] = 0;
    for(int i = 1; i <= V; ++i)
        for(int j = 0; j < (int)E.size(); ++j) {
            int u = E[j].from, v = E[j].to, w = E[j].weight;
            if(dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                st[v] = u;
            }
        }
}

vector<int> path;

void print_path(int v) {
    if(v == s) {
        path.push_back(v);
        for(int i = path.size() - 1; i >= 0; --i)
            printf(""%d%c"", path[i], i ? ' ' : '\n');
        path.clear();
    } else
        print_path(st[v]);
}

int main() {
    scanf(""%d%d%d%d"", &V, &n, &m, &s);
    for(int i = 0; i < n; ++i) {
        int u, v, w;
        scanf(""%d%d%d"", &u, &v, &w);
        E.push_back(edge(u, v, w));
    }
    bellman_ford(s);
    print_path(t);
    return",bitsandbytes
